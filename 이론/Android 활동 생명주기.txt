** Android 활동 생명주기 **

활동 생명주기 단계 간 전환을 위해 6가지 콜백 함수를 활용.

onCreate(), onStart(), onResume(), onPause(), onStop(), onDestroy()

활동 생명주기 단계를 전환하여 시스템을 background와 forwardground를 오가며 실행할 수 있게 한다.
이렇게 함으로써 귀중한 자원을 효율적으로 사용하고, 시스템 안정성을 향상시킬 수 있다. 

* onCreate() 함수

시스템이 활동을 생성할 때 실행되는 함수.
필수로 구현해야 한다. 
활동이 생성되면 '생성됨' 상태가 된다. 
전체 생명주기 동안 한 번만 발생한다. 

* onStart() 함수

활동이 '시작됨' 상태에 들어가면 실행되는 함수.
활동이 사용자에게 표시되고, 앱은 활동을 forwardground에 보내 상호작용할 수 있도록 한다.

* onResume() 함수

활동이 '재개됨' 상태에 들어가면 실행되는 함수.
활동이 포그라운드에 표시되고 시스템이 해당 콜백함수를 호출한다. 
어떤 이벤트가 발생하여 앱에서 포커스가 떠날 때까지 앱은 '재개됨' 상태에 있다. 
이벤트는 전화가 오거나, 사용자가 다른 활동으로 이동하거나, 기기화면이 꺼지는 일 등이 있다. 
방해되는 이벤트가 발생하면 활동은 '일시중지됨' 상태에 들어간다. 
'일시중지됨' 상태에서 '재개됨' 상태로 돌아오면 시스템은 다시 onResume() 메소드를 호출한다. 
다시 말해 onResume()을 통해 재개될 때 초기화, onPause()를 통해 시스템을 해제할 때 구성요소 초기화가 필요하다. 

* onPause() 함수 

사용자가 활동을 떠날 때 실행되는 함수.
해당 활동이 소멸되는 것이 아니라, 활동이 포그라운드에 있지 않게 된 것이다. 

'일시중지됨' 상태로 들어서는 이유는
일부 이벤트에 의한 앱 실행 방해이다. 가장 일반적인 이유다. 
Android 7.0(api level 24)이상에서 여러 앱이 멀티 윈도우에서 실행될 때에 여러 앱(창) 중 
하나만 포커스를 가질 수 있기 때문에 시스템이 나머지 앱을 일시중지로 전환한다. 
화면에 새로운 대화상자가 열렸을 때에 발생한다. 활동은 계속 보이긴 하지만 포커스 상태가 아니기 때문이다. 

시스템 리소스, 센서핸들(GPS) 또는 사용자가 필요로 하지 않을 때의 배터리 수명 등
모든 리소스를 해제하기 위해서도 사용한다. 

대화상자나 멀티 윈도우 환경에서는 일시중지된 활동이 계속 보이게 되므로, 더 나은 멀티 윈도우 환경구성을 위해
UI관련 리소스와 작업을 완전히 해제하거나 조정할 때는 onPause() 메소드보다 onStop() 메소드를 활용하는 것이 낫다. 

* onStop() 함수

활동이 사용자에게 더 이상 표시되지 않도록 하기 위한 함수.
해당 메소드를 통해 시스템은 '중단됨' 상태에 들어가게 된다. 
새로 시작된 활동이 화면 전체를 차지할 경우에 적용된다.
혹은 기존 활동의 실행이 완료되어 종료될 시점에 호출할 수도 있다. 

앱이 사용자에게 보이지 않는 동안 앱이 필요하지 않은 리소스를 해제하거나 조정해야 한다.
애니메이션 일시중지, 세밀한 위치 업데이트에서 대략적 위치 업데이트로의 전환하는데 사용한다. 
CPU를 비교적 많이 소모하는 작업에 대해서는 onStop() 메소드를 적극 활용해야 한다. 
예를 들어 data를 DB에 저장하는 적절한 시기를 찾지 못했다면 onStop() 상태일 때 저장하도록 하는 것이 좋다. 

* onDestroy() 함수

onCreate() 메소드로 생성된 활동이 소멸되기 전에 호출되는 함수.

1. 활동이 종료되는 경우 (사용자가 활동을 정지 / 활동에서 finish()호출)
2. 구성변경 (기기회전 / 멀티 윈도우 모드)으로 인한 시스템의 일시적 활동 소멸
위 경우에 활동이 '소멸됨' 상태로 전환된다. 

활동이 소멸될 시에는 소멸이유를 결정하는 로직을 입력하는 대신 ViewModel 객체를 활용하여 활동과 관련된 뷰 데이터를 포함해야 한다. 
구성변경으로 활동이 재생성되는 경우 ViewModel 객체가 그대로 보존되어 다음 활동 인스턴스에 전달되므로 추가작업이 불필요하다. 
활동이 재생성되지 않을 경우 ViewModel 객체를 onCleared() 메소드로 데이터 정리를 해줘야 한다. 


** 활동 상태 및 메모리에서 제거 **

RAM에 공간이 필요할 경우 시스템은 프로세스를 종료시킨다. 
프로세스 종료는 해당 시점의 프로세스 상태에 따라 달라진다. 
프로세스 상태는 프로세스에서 실행되는 활동상태에 따라 달라진다. 
(종료될 가능성이 적음 < 가능성이 높음)
프로세스 상태 : 포그라운드(포커스 존재) < 백그라운드(포커스 상실) < 백그라운드(보이지 않음) < 비우기
액티비티 상태 : 생성됨 < 시작됨 < 재개됨 < 일시중지됨 < 중지됨 < 소멸됨

시스템은 직접 활동을 종료하지 않는다. 
대신 활동을 실행하는 프로세스를 종료하여 해당 프로세스에 속한 다른 모든 작업을 함께 소멸시킨다. 
사용자도 애플리케이션 관리자를 사용하여 해당 앱을 종료하는 방법으로 프로세스를 종료할 수 있다. 


** 임시 UI 상태 저장 및 복원 **

사용자가 활동을 종료하거나 프로세스를 종료시키는 경우에는 활동 UI상태를 유지할 필요가 없다. 
하지만 시스템 제약으로 인한 활동 소멸의 경우 ViewMode, onSaveInstanceState(), 로컬 저장소를 이용하여
사용자의 임시 UI 상태를 보존해야 한다. 
시스템 제약에 의해 활동이 소멸하면 실제 Activity 인스턴스는 사라지더라도 시스템에 존재했다는 정보는 남아있다. 
그 정보가 시스템 소멸 당시 활동의 상태를 저장하는 데이터 세트이다. 인스턴스 상태라고 부른다.  
이 데이터 세트를 이용하여 해당 활동의 새로운 인스턴스를 생성한다. 
인스턴스 상태는 Bundle 객체에 저장된 key/value 쌍의 컬렉션이다. 
시스템은 Bundle 인스턴스 상태를 사용하여 활동 레이아웃의 각 View 객체 관련 정보를 저장한다. 
따라서 활동 인스턴스가 소멸되고 재생성된 경우, 레이아수의 상태는 별도의 코드를 요하지 않고 이전 상태로 복원된다. 

